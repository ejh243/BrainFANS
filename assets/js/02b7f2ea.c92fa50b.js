"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[678],{5536:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var i=t(4848),o=t(8453);const a={sidebar_position:3,title:"Examples of good and bad code",description:"Examples of good and bad code and what to comment on"},r="Examples of good and bad code",s={id:"Developer-information/Code-review/Code-examples",title:"Examples of good and bad code",description:"Examples of good and bad code and what to comment on",source:"@site/docs/Developer-information/Code-review/Code-examples.md",sourceDirName:"Developer-information/Code-review",slug:"/Developer-information/Code-review/Code-examples",permalink:"/BrainFANS/Developer-information/Code-review/Code-examples",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Examples of good and bad code",description:"Examples of good and bad code and what to comment on"},sidebar:"developerSidebar",previous:{title:"Code Review - Best Practices",permalink:"/BrainFANS/Developer-information/Code-review/Best-practices"},next:{title:"Merge conflicts",permalink:"/BrainFANS/Developer-information/merge-conflicts"}},l={},c=[{value:"Design",id:"design",level:2},{value:"Functionality",id:"functionality",level:2},{value:"Complexity",id:"complexity",level:2},{value:"Readability/Understandability/Maintainability",id:"readabilityunderstandabilitymaintainability",level:2},{value:"Comments",id:"comments",level:2},{value:"Scalability/Expandability",id:"scalabilityexpandability",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"examples-of-good-and-bad-code",children:"Examples of good and bad code"}),"\n",(0,i.jsxs)(n.p,{children:["When conducting a code review, there are many aspects the reviewer should be looking out for. These aspects have been laid out in ",(0,i.jsx)(n.a,{href:"/BrainFANS/Developer-information/Code-review/Conducting-a-code-review#what-to-look-for-in-a-code-review",children:"this list"}),". This page aims to give good and bad examples of code for each of the points on the list. Code is written in python as, ",(0,i.jsx)(n.em,{children:"generally"}),", python is easy to read for those new to programming. To keep consistency across code examples, all code will centre around the factorial function. If you have not heard of this function (or want a reminder), please follow ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Factorial",children:"this link"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"design",children:"Design"}),"\n",(0,i.jsxs)(n.p,{children:["Suppose the file ",(0,i.jsx)(n.code,{children:"main.py"})," currently utilizes an external package, such as numpy, to source the factorial function. Now, imagine a developer creates a pull request where the developer has written their own factorial function, claiming that it is superior to the original implementation."]}),"\n",(0,i.jsxs)(n.p,{children:["This scenario raises concerns about code design and consistency. If the new factorial function is accepted without considering its impact on other parts of the codebase, inconsistencies may arise. To see this, imagine lots of other files in the codebase are still using the external (numpy) version of the factorial function. Accepting this pull request would result in different files using different versions of the factorial function (either the newly written one or the external numpy one). If the two versions of the function differ in terms of output, input (",(0,i.jsx)(n.em,{children:"etc."}),") then the codebase becomes more difficult to work with. When the factorial function is needed in a future file, which one should the developer pick? If another file relies on two separate scripts that each use a different version of the factorial function, will the output be as expected (perhaps the differences between the versions of the function lead to incompatibility)?"]}),"\n",(0,i.jsxs)(n.p,{children:["While this example focuses on the factorial function, the same principle applies to (and is more relevant for) more complex libraries, functions, classes (",(0,i.jsx)(n.em,{children:"etc."}),"). Even if the content of the pull request is deemed objectively better\u2014such as being faster\u2014it may produce results that differ from the original code, leading to inconsistencies across the repository."]}),"\n",(0,i.jsx)(n.p,{children:"By carefully evaluating proposed code changes in the context of the existing codebase, we can avoid introducing inconsistencies and maintain the overall stability and coherence of the system."}),"\n",(0,i.jsxs)(n.p,{children:["Note that this is not to say that any fundamental changes to the repository should be rejected. Maybe a 'better' version of a function ",(0,i.jsx)(n.em,{children:"is"})," required for optimisation. The important aspect of 'design' is that the new code will integrate properly with the rest of the codebase. In the example scenario, if all instances of the factorial function across the codebase were changed (and it was genuinely 'better'), then the pull request can still be accepted."]}),"\n",(0,i.jsx)(n.h2,{id:"functionality",children:"Functionality"}),"\n",(0,i.jsx)(n.p,{children:"The best way to check functionality is in testing the code yourself. Consider the below code blocks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="non-functional code"',children:"# This function will not work as 'result' is not initialised before being\n# used in calculations\ndef factorial(n):\n    for i in range(1, n + 1):\n        result = result * i\n    return result\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Good code"',children:"# The function now outputs the correct value but does not handle edge cases\n# such as the user inputting a letter instead of a number etc.\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i\n    return result\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Better code"',children:"# The function now outputs the correct value and accounts for the case\n# where the user does not input a non-negative integer\ndef factorial(n):\n    if not isinstance(n, int) or n < 0:\n        return None\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i\n    return result\n"})}),"\n",(0,i.jsx)(n.h2,{id:"complexity",children:"Complexity"}),"\n",(0,i.jsx)(n.p,{children:"Code that is more complex than it needs to be is generally bad."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="highly complex code"',children:"import math\n\n# Don't worry about what this code does. In a nutshell the gamma function will \n# return the factorial function for x greater than or equal to 1. \n# However it is defined for all real numbers, not just non-negative integers.\n\n# Also note that this approximation of the gamma function isn't even very\n# accurate.\n\ndef gamma_function(x):\n    if x == 1:\n        return 1\n    elif x < 0.5:\n        return math.pi / (math.sin(math.pi * x) * gamma_function(1 - x))\n    else:\n        x -= 1\n        a = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n             771.32342877765313, -176.61502916214059, 12.507343278686905,\n             -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7]\n        t = a[0]\n        for i in range(1, len(a)):\n            t += a[i] / (x + i)\n        return math.sqrt(2 * math.pi) * (x + 4.5) ** (x - 0.5) * math.exp(-x - 4.5) * t\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Better code"',children:"# For most purposes, the below code does the exact same thing as the 'bad' code\n# Considering the below code is much less complex, it is viewed as better\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i\n    return result\n"})}),"\n",(0,i.jsx)(n.h2,{id:"readabilityunderstandabilitymaintainability",children:"Readability/Understandability/Maintainability"}),"\n",(0,i.jsx)(n.p,{children:"These topics all roll into one for the majority of purposes. What they come down to is: Code is not just for the developer who wrote it; but for others to read, use and maintain. If the reviewer is unable to read/understand some code, it will likely be harder for other developers to work on the file in the future."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Bad code"',children:'# If you didn\'t have the preconception that this was the factorial funciton\n# would you instantly recognise what this is doing? Would you be comfortable in\n# making any changes? Can you spot the bug in this code?\ndef f(n):\n    if isinstance(n, int):\n        if n < 0:\n            r = 1\n            [r := r * i for i in range(1, n+1)]\n            return r\n        else:\n            print("invalid n")\n    else:\n        print("invalid n")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Better code"',children:"# In general, this is (hopefully) easier to understand\ndef factorial(n):\n    if not isinstance(n, int) or n < 0:\n        return None\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i\n    return result\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that readability/understandability/maintainability can be subjective in lots of scenarios. For now, if you, the reviewer, understands the code to a 'good enough' degree (and you are not completely lost), the code is fine and does not warrant a refactoring. There is ",(0,i.jsx)(n.a,{href:"/BrainFANS/Developer-information/Code-review/Best-practices#there-is-no-perfect-code",children:"no such thing as perfect code"}),". It is very easy to go back and forth on what makes code cleaner and easier to read, but all this really ends up doing is wasting time. If the proposed changes demonstrate reasonable readability and improve the existing codebase, approve the request."]}),"\n",(0,i.jsx)(n.admonition,{title:"Clean code",type:"info",children:(0,i.jsx)(n.p,{children:"Clean code is a set of programming principles that aims for consistent naming conventions, function structure and minimal complexity. To a degree, clean code is great for achieving the points on this list. But it also comes with the drawbacks of performance hits and sometimes (paradoxically) decreased readability and understandability. A developer can go too far the other way with readability/understandability/maintainability. Strive for 'good enough', a compromise between easy to read and easy to write."})}),"\n",(0,i.jsx)(n.h2,{id:"comments",children:"Comments"}),"\n",(0,i.jsxs)(n.p,{children:['A good rule of thumb is: "comments explain ',(0,i.jsx)(n.em,{children:"why, not what"}),'". To see the difference, the examples below have the same code, but the first comments the ',(0,i.jsx)(n.em,{children:"what"})," and the seconf the ",(0,i.jsx)(n.em,{children:"why"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Commenting on what"',children:"# Define the factorial function\ndef factorial(n):\n    # Checks if the input is not an integer or less than zero\n    if not isinstance(n, int) or n < 0:\n        # Returns None if the input is not an integer or less than zero\n        return None\n    # Initialises 'result' to be 1\n    result = 1\n    # Creates a loop that starts at index 1 and ends at index n\n    for i in range(1, n + 1):\n        # Multiplies 'result' by the current index of the for loop\n        result = result * i\n    # returns the result of the function\n    return result\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Commenting on why"',children:'def factorial(n):\n    # The factorial function is not defined for non-negative integers,\n    # error handling is required in case the user does not enter such. \n    if not isinstance(n, int) or n < 0:\n        return None\n    result = 1\n    for i in range(1, n + 1):\n        # The factorial function is defined as: "The product of all integers\n        # up to the input".\n        result = result * i\n    return result\n'})}),"\n",(0,i.jsxs)(n.p,{children:['The above is obviously an egregious use of comments. Python is readable enough that none of the above comments are particularly required. However, hopefully you can see that explaining "',(0,i.jsx)(n.em,{children:"what"}),'" really does not help the reader.']}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes, explaining ",(0,i.jsx)(n.em,{children:"what"})," the code does feel like a necessity. In such cases we refer back to our stance on ",(0,i.jsx)(n.a,{href:"#complexity",children:"complex code"}),". If the code is complex enough that ",(0,i.jsx)(n.em,{children:"what"}),"-based comments are required, then the code would likely benefit from being refactored. The exception to this is circumstances like regular expressions. If the code uses something like regex, then the comments should explain what the code is doing. Computers read regex, humans do not (well, not easily)."]}),"\n",(0,i.jsx)(n.h2,{id:"scalabilityexpandability",children:"Scalability/Expandability"}),"\n",(0,i.jsx)(n.p,{children:"Can the code be repurposed in a new context? We appreciate that spotting scalability problems is usually rather difficult in more complex codebases without lots of domain knowledge. Generally, you should be looking to see if some code can be modularised so that it can be repurposed elsewhere."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Bad code"',children:"# ... Code ... #\n# ... Code ... #\n\nfactorial = 1\nfor i in range(1, 6):\n    factorial = factorial * i\nprint(factorial)\n\n\n# ... Code ... #\n# ... Code ... #\n\nfactorial = 1\nfor i in range(1, 11):\n    factorial = factorial * i\nprint(factorial)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The above code is the same factorial function, but it is just being used inside the codebase for specific scenarios (here, it calculates 5! and 10!). This is not desirable as we can't reuse the factorial in other parts of the codebase easily. Here, you would need to copy and paste the code block and know that the ",(0,i.jsx)(n.code,{children:"range"})," needed to be changed to n+1 (to calculate n!)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Better code"',children:"# This function can be called from anywhere with 'factorial(n)' and is more\n# versatile\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i\n    return result\n"})}),"\n",(0,i.jsxs)(n.admonition,{title:"DRY",type:"info",children:[(0,i.jsx)(n.p,{children:"A common term you might hear in programming/software engineering spaces is DRY:"}),(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"DRY"})," principle: ",(0,i.jsx)(n.em,{children:"Don't repeat yourself"}),"."]}),"\n"]}),(0,i.jsx)(n.p,{children:"This principle comes from the idea that: if you repeat yourself a lot in code, making changes in the future becomes much more cumbersome. Taking on this principle can help a lot with making code scalable as it often results in more modular code."}),(0,i.jsxs)(n.p,{children:["However, one can go too far with DRY and end up with difficult to understand code. You do not ",(0,i.jsx)(n.em,{children:"need"}),' code to be heavily abstracted wherever possible. The DRY principle should be used when the repetition becomes a problem, not when it "might become a problem".']})]}),"\n",(0,i.jsxs)(n.p,{children:['Alongside repetition, another aspect of code that can increase scalability is: "Functions/Classes (constructs) should do ',(0,i.jsx)(n.em,{children:"one"})," thing\". This is also known as the 'single-responsibility principle'. Functions that do lots of things are harder to reimplement elsewhere. Functions that do a single thing are more modular and can be repurposed. Consider the two following examples:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Bad code"',children:'# This seems harmless enough, you call the factorial function and it outputs the\n# answer. However, this function is doing TWO things. First, it evaluates the \n# factorial then second, it prints the answer. What if we just wanted the\n# answer and not the printed sentence? This function is not very modular.\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i\n    print("The factorial of", n, "is", result)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Better code"',children:"# This function now does one thing, it returns the value of n!.\n# If we wanted to print the answer in a sentence, we could achieve this with\n# a different line of code (or function) outside of the factorial function.\n# This way the function can be used for a variety of purposes.\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i\n    return result\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);